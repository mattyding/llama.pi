######################################################################
# you should not have to modify below.
#
# the enclosing makefile should define:
#   1. <LIBNAME> = name of the produced archive.  
#   2. <SRC> = the source files.
# optional:
#   - <TAG_PROG> = program to compute tags (ctags, etags)
#   - <STAFF_OBJS> = object files that are included as-is.
#   - <BUILD_DIR> = the directory for all .o, .d and temporary files.
#   - can add to the <libs::> and <all::> targets.
#   - can add more libraries to <LIBS>
#   - <LINK_DEPS>: add any dependencies needed for linking.

######################################################################
# 1. error checking and config

ifndef LIBNAME
$(error <LIBNAME> is not set in the calling Makefile)
endif
export LIBNAME

ifndef SRC
$(error <SRC> is not set in the calling Makefile)
endif

# default: put it in <objs>
BUILD_DIR ?= ./objs

ifeq ($(BUILD_DIR),.)
$(error "BUILD_DIR cannot be '.' or clean will remove everything.")
endif
ifeq ($(BUILD_DIR),)
$(error "BUILD_DIR cannot be empty.")
endif

# if they want use to spit all the -I commands into a file.
ifdef GEN_INCLUDES
GEN_INCLUDES = lib-includes.mk
endif

# export all of the makefile variables.
export TTYUSB 
export BOOTLOADER
export GREP_STR 

MAKEFLAGS += --no-print-directory

TAG_PROG ?= ctags

######################################################################
# 2. compute all needed variables.

# include libpi definitions.
DEFS = $(CS140E_2024_PATH)/libpi/defs.mk
include $(DEFS)

# add the memmap file and the Makefiles as dependencies
#   - libpi serves as a sentinal covering everything in libpi
#     keep any DEPS that the client defined.
DEPS += $(MEMMAP) ./Makefile $(LPP)/mk/Makefile.lib.template-v2 $(DEFS)

# compute object and dep names, relocate to the <BUILD_DIR>
LIB_OBJS := $(SRC:.c=.o) $(LIB_OBJS)
LIB_OBJS := $(LIB_OBJS:.S=.o)
LIB_OBJS := $(LIB_OBJS:.s=.o)
lib_objs := $(foreach o, $(LIB_OBJS), $(BUILD_DIR)/$(notdir $o)) 
lib_deps := $(lib_objs:.o=.d)

# compute all directories for vpath and includes
lib_dirs :=  $(sort $(dir $(SRC)))
VPATH := ./ $(BUILD_DIR) $(lib_dirs)

# all include flags
all_inc := $(foreach o, $(abspath $(lib_dirs)), -I$o) 

# all the headers in all the directories.
all_hdr := $(foreach d, $(lib_dirs), $(wildcard $d/*.h)) 

CFLAGS += $(all_inc)
CFLAGS += $(EXTRA_CFLAGS) 


# if we are building libpi.a don't add it as a dependency!
ifneq ($(LIBNAME),libpi.a)
ifneq ($(LIBNAME),libpi-fp.a)
LINK_DEPS += $(LPI)

# put lib first so we take symbols from there.
# had a very weird error where a foo.o was appearing in libpi.  wth.
LIBS += $(LIBNAME) $(LPI) 

else
LIBS = $(LPI) 
endif
endif

####################################################################
# 3. make compilation rules.
#

all:: $(BUILD_DIR) $(GEN_INCLUDES) libs $(LIBNAME) # tags

lib-includes.mk: $(DEPS)
	@echo "INC += $(all_inc)" > lib-includes.mk

$(BUILD_DIR): 
	mkdir -p $(BUILD_DIR)

# we delete the archive before creating so that the hack of
# having duplicate symbols in it resolved in order works.
$(LIBNAME): $(lib_objs) $(STAFF_OBJS) $(LINK_DEPS)
	@rm -f $@
	$(AR) crf $@ $(lib_objs) $(STAFF_OBJS)
	$(OD) -D $@ > $@.list

# rules to generate .o from .c and .S files.
# NOTE:
#  1. we explicitly force a .d file to be 
#     present to catch mistakes in mis-specifying 
#     them.  
#  2. we use a '|' (order only) rule b/c we only
#     need the <BUILD_DIR> to exist; we don't care about
#     its timestamp.
$(BUILD_DIR)/%.o: %.c $(BUILD_DIR)/%.d $(DEPS) |  $(BUILD_DIR)
	$(CC) $(CFLAGS) -MMD -MP -c $< -o $@
$(BUILD_DIR)/%.o: %.S $(BUILD_DIR)/%.d $(DEPS)| $(BUILD_DIR)
	$(CC) $(CPP_ASFLAGS) -MMD -MP -c $< -o $@

# b/c of our explicit dependencies on .d files, we tell
# 'make' not to panic if no .d exists since it will
# get generated by the end.  (you can test this by deleting
# the .d and seeing that it and its associated .o will
# get regenerated correctly)
$(BUILD_DIR)/%.d: ;

# if we are building libpi.a don't rerun make
#   @make -s -C $(LPP)
# otherwise rebuild.
#
# double colon is so user can add transparently.
libs::
ifneq ($(LIBNAME),libpi.a)
ifneq ($(LIBNAME),libpi-fp.a)
	make -C $(LPP)
endif
endif

# manually add rule for libpi.a
$(LPI):
	@make -s -C $(LPP)

# don't include <lib_deps> if we are doing
# "make clean" to prevent spurious error
# messages.
ifneq ($(MAKECMDGOALS),clean)
ifneq ($(MAKECMDGOALS),cleanall)
-include $(lib_deps)  # include dep files
endif
endif

# generate tags file.  note: if you need a different tags, need
# a different target.
tags: $(all_hdr) $(SRC)
	@$(TAG_PROG) $(all_hdr) $(SRC)

# note: double :: is so user can add additional clean rules.
clean::
	rm -rf $(BUILD_DIR)/ $(LIBNAME) *~ *.list Makefile.bak lib-includes.mk tags

.PHONY: libs all clean 
.PRECIOUS:  $(BUILD_DIR)/%.o $(BUILD_DIR)/%.d %.list %.elf
