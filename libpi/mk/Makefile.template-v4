######################################################################
# you should not have to modify below.
#
# takes files from a bunch of directories and emits them into a build_dir.
#
# the enclosing makefile should define:
#   1. <PROGS> =  the different programs to make.
# optional common source and .o files to be linked w all <PROGS>
#   - <COMMON_SRC> = the source files
#   - <COMMON_OBJS> = can also specify .o's for .c and .S files.
#   - <STAFF_OBJS> = pre-built .o's -- these won't be deleted by clean.
# optional:
#   - <TAG_PROG> = program to compute tags (ctags, etags)
#   - <BUILD_DIR> = the directory for all .o, .d and temporary files.
#   - can add to the <libs::> and <all::> targets.
#   - can add more libraries to <LIBS>
#   - <LINK_DEPS>: add any dependencies needed for linking.


######################################################################
# 1. Error checking and config.

MAKEFLAGS += --no-print-directory
BUILD_DIR ?= ./objs

# sanity checks.
ifndef PROGS
    $(error "PROGS is not defined.")
endif
ifeq ($(BUILD_DIR),.)
    $(error "BUILD_DIR cannot be '.' or clean will remove everything.")
endif
ifeq ($(BUILD_DIR),)
    $(error "BUILD_DIR cannot be empty.")
endif
ifneq ($(RUN),0)
    RUN_PROGS = run
endif


ifdef BOOTLOADER
export BOOTLOADER
endif

ifdef GREP_STR
export GREP_STR
endif

ifdef START
export START
endif

# add libpi to LIBS
LIBS += $(LIB) $(LPI) 

include $(CS140E_2024_PATH)/libpi/defs.mk

ifndef MK_CHK
    MK_CHK := $(LPP)/mk/Makefile.check-v3
endif


######################################################################
# 2. compute all needed variables.

# grab all the source: XXX COMMON_SRC should be .S as well?
objs := $(COMMON_OBJS) $(COMMON_SRC:.c=.o)
objs := $(objs:.S=.o)
objs := $(objs:.s=.o)

test_run := $(PROGS:.c=.run)

deps = $(objs:.o=.d) $(PROGS:.c=.d)

# all locations of built objects
locs := $(objs) $(PROGS)
dirs :=  $(sort $(dir $(locs)))

# compute object and dep names, relocate to <BUILD_DIR>
deps := $(foreach o, $(deps), $(BUILD_DIR)/$(notdir $(o)))
objs := $(foreach o, $(objs), $(BUILD_DIR)/$(notdir $(o)))

# all objects: built, and pre-built.
all_objs := $(objs) $(STAFF_OBJS) 

# tell make where to look.
VPATH := ./ $(BUILD_DIR)/ $(dirs) 

all_tags := $(foreach d, $(dirs), $(d)*.[cSh])

CFLAGS += $(foreach d, $(dirs), -I$(d))
headers += $(foreach d, $(dirs), $(d)/*.h)

# we might not need these.
test_bin    := $(PROGS:.c=.bin)
test_list   := $(PROGS:.c=.list)
test_elf    := $(PROGS:.c=.elf)
test_dep    := $(PROGS:.c=.d)

.SUFFIXES: .run


# all the makefile dependencies: force recompile if these change.
mk = $(LPP)/mk/Makefile.template-v4 ./Makefile $(LPP)/defs.mk
DEPS += $(MEMMAP) $(LPI)  $(mk)

all:: $(BUILD_DIR) libs $(LIB) $(test_bin) $(RUN_PROGS) 

$(BUILD_DIR):  FORCE
	@mkdir -p $(BUILD_DIR)

print:
	@echo "objs=<$(objs)>"
	@echo "allobjs=<$(all_objs)>"
	@echo "dirs=<$(dirs)>"
	@echo "VPATH=<$(VPATH)>"

FORCE:

# double colon is so user can add transparently.
libs:: FORCE
	@make -s -C $(LPP)
FORCE:

$(LPI):
	@make -s -C $(LPP)

# how to tell it not to remake start?
$(BUILD_DIR)/%.elf: $(BUILD_DIR)/%.o $(BUILD_DIR)/%.d $(all_objs) $(DEPS) $(START) $(LIBS) 
	$(LD) $(LDFLAGS) $(START)  $< $(all_objs) -T $(MEMMAP) -o $@ $(LIBS) $(LIB_POST)


# rules to generate .o from .c and .S files.
# NOTE:
#  1. we explicitly force a .d file to be 
#     present to catch mistakes in mis-specifying 
#     them.  
#  2. we use a '|' (order only) rule b/c we only
#     need the <BUILD_DIR> to exist; we don't care about
#     its timestamp.
$(BUILD_DIR)/%.o: %.c  $(BUILD_DIR)/%.d $(DEPS)  | $(BUILD_DIR)
	$(CC) $(CFLAGS) -MMD -MP -c $< -o $@
$(BUILD_DIR)/%.o: %.S $(BUILD_DIR)/%.d $(DEPS)  | $(BUILD_DIR)
	$(CC) $(CPP_ASFLAGS) -MMD -MP -c $< -o $@

# b/c of our explicit dependencies on .d files, we tell
# 'make' not to panic if no .d exists since it will
# get generated by the end.  (you can test this by deleting
# the .d and seeing that it and its associated .o will
# get regenerated correctly)
$(BUILD_DIR)/%.d: ;

%.list: $(BUILD_DIR)/%.elf
	$(OD) -d $< > $@
%.bin: %.list $(DEPS)
	$(OCP) $(BUILD_DIR)/$*.elf -O binary $*.bin

%.run: %.bin
	$(BOOTLOADER) $(TTYUSB) ./$<
run: $(test_run)

ifneq ($(CAN_EMIT), 0)
emit: libs $(DEPS) $(test_bin) FORCE
	@make -e -f $(MK_CHK) emit "TESTS=$(test_bin)"
endif

check: libs $(DEPS) $(test_bin)
	@make -f $(MK_CHK) check "TESTS=$(test_bin)"

ifneq ($(MAKECMDGOALS),clean)
ifneq ($(MAKECMDGOALS),cleanall)
-include $(dep)  # include dep files
endif
endif

# XXX: should do tags of all the source.  make a variable.
tags::
	ctags $(all_tags)

# note: double :: is so user can add rules to <clean> transparently
clean::
	rm -rf $(BUILD_DIR) $(test_bin) $(test_list)
	rm -f *~ tags Makefile.bak  *.test

.PHONY: libs all tags clean FORCE run check

# stop make from deleting these suffix'd files.
.PRECIOUS: %.list %.elf $(BUILD_DIR)/%.o $(BUILD_DIR)/%.d $(BUILD_DIR)/%.elf
